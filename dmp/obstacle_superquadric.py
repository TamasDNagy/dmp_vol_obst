'''
Copyright (C) 2018 Michele Ginesi

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see <http://www.gnu.org/licenses/>.
'''

import numpy as np
import copy

class Obstacle_Static():
    '''
    Implementation of an obstacle for Dynamic Movement Primitives written as a
    general n-ellipsoid
      / x - x_c \ 2n     / y - y_c \ 2n      / z - z_c \ 2n
      |---------|     +  |---------|     +   |---------|     =  1
      \    a    /        \    b    /         \    c    /
    '''

    def __init__(self, center = np.zeros(2), axis = np.ones(2),
            coeffs = np.ones(2), A = 1.0, eta = 1.0, **kwargs):
        '''
        n_dim int     : dimension of the space (usually 2 or 3)
        center float  : array containing the coordinates of the center of the
                        ellipsoid
        axis float    : array containing the lengths of the ais of the
                        ellipsoid
        '''
        self.center = copy.deepcopy(center)
        self.axis = copy.deepcopy(axis)
        self.A = copy.deepcopy(A)
        self.eta = copy.deepcopy(eta)
        self.n_dim = np.size(self.axis)
        self.coeffs = copy.deepcopy(coeffs)
        return

    def gen_external_force(self, x):
        '''
        Compute the forcing term generated by the potential U as
          varphi(x) = - nabla U
        '''

        phi = np.zeros(self.n_dim)
        for i in range(self.n_dim):
            phi[i] = (((x[i] - self.center[i]) ** (2 * self.coeffs[i] - 1)) /
                (self.axis[i] ** (2 * self.coeffs[i])))
        K = self.compute_isopotential(x)
        phi *= (self.A * np.exp(-self.eta*K)) * (self.eta / K + 1. / K / K) * (2 * self.coeffs)
        return phi

    def compute_potential(self, x):
        '''
        Compute the potential
                 exp (- eta K)
          U = A ---------------
                       K
        '''

        K = self.compute_isopotential (x)
        U = self.A * np.exp(- self.eta * K) / K
        return U

    def compute_isopotential(self, x):
        '''
        Compute the isopotential of the obstacle
                / x - x_c \ 2n     / y - y_c \ 2n      / z - z_c \ 2n
          K  =  |---------|     +  |---------|     +   |---------|     -  1
                \    a    /        \    b    /         \    c    /
        '''

        K = 0.
        for i in range(self.n_dim):
            K += ((x[i] - self.center[i]) / self.axis[i]) ** (2 * self.coeffs[i])
        K -= 1
        return K
